 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/supabase/functions/subscriptions-scheduler/index.ts b/supabase/functions/subscriptions-scheduler/index.ts
index 2ba7918dd0c652653ae9b2899d951d91180939ee..2863398839985a407c128aad3d81f80b47b73907 100644
--- a/supabase/functions/subscriptions-scheduler/index.ts
+++ b/supabase/functions/subscriptions-scheduler/index.ts
@@ -1,53 +1,64 @@
-import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';
+import { createClient, type SupabaseClient } from 'https://esm.sh/@supabase/supabase-js@2';
 import { DateTime } from 'https://esm.sh/luxon@3';
 
 const corsHeaders = {
   'Access-Control-Allow-Origin': '*',
   'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
 };
 
 interface SubscriptionRecord {
   id: string;
   title: string;
   amount: number;
   currency: string;
+  accepted_cryptos: string[];
   interval: string;
   interval_count: number;
   next_billing_at: string;
   status: string;
   max_cycles?: number;
   total_cycles: number;
   merchant_id: string;
   customer_id: string;
   invoice_due_days: number;
   generate_days_in_advance: number;
+  past_due_after_days: number;
   merchants: {
     id: string;
     business_name: string;
     timezone?: string;
+    wallets: Record<string, string> | null;
+    charge_customer_fee?: boolean | null;
+    auto_convert_enabled?: boolean | null;
+    preferred_payout_currency?: string | null;
   };
+  charge_customer_fee?: boolean | null;
+  auto_convert_enabled?: boolean | null;
+  preferred_payout_currency?: string | null;
+  tax_enabled?: boolean | null;
+    tax_rates?: Array<{ percentage: number; label: string }> | null;
   customers: {
     id: string;
     name?: string;
     email: string;
   };
 }
 
 interface AmountOverride {
   id: string;
   amount: number;
   effective_from: string;
   effective_until?: string;
   note?: string;
 }
 
 // Generate unique link ID for payment links
 function generateLinkId(): string {
   const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
   let result = 'pl_';
   for (let i = 0; i < 9; i++) {
     result += chars.charAt(Math.floor(Math.random() * chars.length));
   }
   return result;
 }
 
diff --git a/supabase/functions/subscriptions-scheduler/index.ts b/supabase/functions/subscriptions-scheduler/index.ts
index 2ba7918dd0c652653ae9b2899d951d91180939ee..2863398839985a407c128aad3d81f80b47b73907 100644
--- a/supabase/functions/subscriptions-scheduler/index.ts
+++ b/supabase/functions/subscriptions-scheduler/index.ts
@@ -60,51 +71,51 @@ function calculateNextBillingDate(currentDate: DateTime, interval: string, inter
       return currentDate.plus({ weeks: intervalCount });
     case 'month':
       return currentDate.plus({ months: intervalCount });
     case 'year':
       return currentDate.plus({ years: intervalCount });
     default:
       throw new Error(`Unsupported interval: ${interval}`);
   }
 }
 
 // Get applicable amount override for a specific date
 function getApplicableOverride(overrides: AmountOverride[], cycleDate: string): AmountOverride | null {
   const applicableOverrides = overrides.filter(override => 
     override.effective_from <= cycleDate && 
     (!override.effective_until || override.effective_until >= cycleDate)
   );
   
   // Return the most recent applicable override
   return applicableOverrides.sort((a, b) => 
     b.effective_from.localeCompare(a.effective_from)
   )[0] || null;
 }
 
 // Generate invoice for a subscription
 async function generateInvoiceForSubscription(
-  supabase: any, 
+  supabase: SupabaseClient,
   subscription: SubscriptionRecord,
   overrides: AmountOverride[]
 ): Promise<{ success: boolean; error?: string; invoiceId?: string; paymentUrl?: string }> {
   try {
     console.log(`🔄 Processing subscription: ${subscription.id} (${subscription.title})`);
     
     const timezone = subscription.merchants.timezone || 'UTC';
     const now = DateTime.now().setZone(timezone);
     const nextBilling = DateTime.fromISO(subscription.next_billing_at).setZone(timezone);
     const cycleStart = nextBilling;
     const cycleStartISO = cycleStart.toISODate();
     
     // Check if we should generate the invoice (considering generate_days_in_advance)
     const generateDate = nextBilling.minus({ days: subscription.generate_days_in_advance });
     
     if (now < generateDate) {
       console.log(`⏳ Too early to generate invoice for ${subscription.id}. Generate date: ${generateDate.toISO()}`);
       return { success: false, error: 'Too early to generate' };
     }
     
     // Check if invoice already exists for this cycle (idempotency)
     const { data: existingInvoice } = await supabase
       .from('subscription_invoices')
       .select('id, payment_link_id')
       .eq('subscription_id', subscription.id)
diff --git a/supabase/functions/subscriptions-scheduler/index.ts b/supabase/functions/subscriptions-scheduler/index.ts
index 2ba7918dd0c652653ae9b2899d951d91180939ee..2863398839985a407c128aad3d81f80b47b73907 100644
--- a/supabase/functions/subscriptions-scheduler/index.ts
+++ b/supabase/functions/subscriptions-scheduler/index.ts
@@ -118,70 +129,149 @@ async function generateInvoiceForSubscription(
     
     // Check max cycles limit
     if (subscription.max_cycles && subscription.total_cycles >= subscription.max_cycles) {
       console.log(`🏁 Subscription ${subscription.id} has reached max cycles (${subscription.max_cycles})`);
       
       // Mark subscription as completed
       await supabase
         .from('subscriptions')
         .update({ 
           status: 'completed',
           completed_at: now.toISO()
         })
         .eq('id', subscription.id);
         
       return { success: false, error: 'Max cycles reached' };
     }
     
     // Get applicable amount override
     const applicableOverride = getApplicableOverride(overrides, cycleStartISO);
     const invoiceAmount = applicableOverride?.amount || subscription.amount;
     
     console.log(`💰 Invoice amount: $${invoiceAmount} ${subscription.currency} ${applicableOverride ? '(override applied)' : '(base amount)'}`);
     
     // Calculate due date
     const dueDate = cycleStart.plus({ days: subscription.invoice_due_days });
-    
+    const pastDueDays = subscription.past_due_after_days ?? 2;
+    const expiresAt = cycleStart.plus({ days: pastDueDays + 14 });
+
     // Generate unique link ID
     const linkId = generateLinkId();
-    
-    // Create payment link first
+
+    const defaultCryptos = ['BTC', 'ETH', 'LTC']
+    const hasCustomCryptos =
+      Array.isArray(subscription.accepted_cryptos) &&
+      subscription.accepted_cryptos.length > 0 &&
+      !(
+        subscription.accepted_cryptos.length === defaultCryptos.length &&
+        defaultCryptos.every(c => subscription.accepted_cryptos.includes(c))
+      )
+
+    const acceptedCryptos = hasCustomCryptos
+      ? subscription.accepted_cryptos
+      : Object.keys(subscription.merchants.wallets || {})
+
+    const walletAddresses = acceptedCryptos.reduce(
+      (acc: Record<string, string>, crypto) => {
+        const addr = subscription.merchants.wallets?.[crypto];
+        if (addr) acc[crypto] = addr;
+        return acc;
+      },
+      {} as Record<string, string>
+    );
+
+    // Calculate tax and fee information just like manual payment links
+    const effectiveChargeCustomerFee =
+      subscription.charge_customer_fee ?? subscription.merchants.charge_customer_fee ?? false;
+    const effectiveAutoConvertEnabled =
+      subscription.auto_convert_enabled ?? subscription.merchants.auto_convert_enabled ?? false;
+    const effectivePreferredPayoutCurrency =
+      subscription.preferred_payout_currency ?? subscription.merchants.preferred_payout_currency ?? null;
+
+    let totalTaxAmount = 0;
+    const taxBreakdown: Record<string, number> = {};
+    if (subscription.tax_enabled && Array.isArray(subscription.tax_rates)) {
+      for (const rate of subscription.tax_rates) {
+        const pct = Number(rate.percentage) || 0;
+        const amt = (invoiceAmount * pct) / 100;
+        totalTaxAmount += amt;
+        taxBreakdown[rate.label.toLowerCase().replace(/\s+/g, '_')] = amt;
+      }
+    }
+
+    const subtotalWithTax = invoiceAmount + totalTaxAmount;
+    const baseFeePct = 0.005; // 0.5%
+    const autoConvertFeePct = effectiveAutoConvertEnabled ? 0.005 : 0;
+    const totalFeePct = baseFeePct + autoConvertFeePct;
+    const feeAmount = subtotalWithTax * totalFeePct;
+    const customerPaysTotal =
+      effectiveChargeCustomerFee ? subtotalWithTax + feeAmount : subtotalWithTax;
+    const merchantReceives = subtotalWithTax - feeAmount;
+
+    // Create payment link with full metadata
     const { data: paymentLink, error: linkError } = await supabase
       .from('payment_links')
       .insert({
         merchant_id: subscription.merchant_id,
         title: `${subscription.title} - Invoice`,
         amount: invoiceAmount,
+        base_amount: invoiceAmount,
         currency: subscription.currency,
         link_id: linkId,
         subscription_id: subscription.id,
         source: 'subscription',
+        accepted_cryptos: acceptedCryptos,
+        charge_customer_fee: effectiveChargeCustomerFee,
+        auto_convert_enabled: effectiveAutoConvertEnabled,
+        preferred_payout_currency: effectivePreferredPayoutCurrency,
+        fee_percentage: totalFeePct,
+        tax_enabled: subscription.tax_enabled,
+        tax_rates: subscription.tax_rates,
+        tax_amount: totalTaxAmount,
+        subtotal_with_tax: subtotalWithTax,
+        expires_at: expiresAt.toISO(),
+        max_uses: 1,
         metadata: {
           subscription_id: subscription.id,
           cycle_start_at: cycleStartISO,
           cycle_number: subscription.total_cycles + 1,
-          type: 'subscription_invoice'
+          type: 'subscription_invoice',
+          wallet_addresses: walletAddresses,
+          fee_breakdown: {
+            base_fee_percentage: baseFeePct * 100,
+            auto_convert_fee_percentage: autoConvertFeePct * 100,
+            total_fee_percentage: totalFeePct * 100,
+            fee_amount: feeAmount,
+            merchant_receives: merchantReceives,
+            effective_charge_customer_fee: effectiveChargeCustomerFee,
+            effective_auto_convert_enabled: effectiveAutoConvertEnabled,
+            effective_preferred_payout_currency: effectivePreferredPayoutCurrency
+          },
+          tax_breakdown: taxBreakdown,
+          base_amount: invoiceAmount,
+          total_amount: customerPaysTotal,
+          fee_amount: feeAmount
         }
       })
       .select('id, link_id')
       .single();
       
     if (linkError) {
       console.error(`❌ Failed to create payment link for ${subscription.id}:`, linkError);
       return { success: false, error: 'Failed to create payment link' };
     }
     
     // Generate proper invoice number using atomic counter
     const { data: invoiceNumber, error: numberError } = await supabase
       .rpc('get_next_invoice_number', { merchant_uuid: subscription.merchant_id });
     
     if (numberError) {
       console.error(`❌ Failed to generate invoice number for ${subscription.id}:`, numberError);
       return { success: false, error: 'Failed to generate invoice number' };
     }
     
     console.log(`📄 Generated invoice number: ${invoiceNumber}`);
     
     // Create subscription invoice record
     const { data: invoice, error: invoiceError } = await supabase
       .from('subscription_invoices')
       .insert({
diff --git a/supabase/functions/subscriptions-scheduler/index.ts b/supabase/functions/subscriptions-scheduler/index.ts
index 2ba7918dd0c652653ae9b2899d951d91180939ee..2863398839985a407c128aad3d81f80b47b73907 100644
--- a/supabase/functions/subscriptions-scheduler/index.ts
+++ b/supabase/functions/subscriptions-scheduler/index.ts
@@ -219,51 +309,51 @@ async function generateInvoiceForSubscription(
     if (updateError) {
       console.error(`❌ Failed to update subscription ${subscription.id}:`, updateError);
       return { success: false, error: 'Failed to update subscription' };
     }
     
     // Generate payment URL
     const appOrigin = Deno.env.get('APP_ORIGIN') || 'https://cryptrac.com';
     const paymentUrl = `${appOrigin}/pay/${paymentLink.link_id}`;
     
     console.log(`✅ Invoice created for ${subscription.id}: ${invoice.id}`);
     
     return { 
       success: true, 
       invoiceId: invoice.id,
       paymentUrl: paymentUrl
     };
     
   } catch (error) {
     console.error(`❌ Error generating invoice for ${subscription.id}:`, error);
     return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };
   }
 }
 
 // Send invoice notification email
 async function sendInvoiceNotification(
-  supabase: any,
+  supabase: SupabaseClient,
   subscription: SubscriptionRecord,
   paymentUrl: string,
   invoiceAmount: number
 ): Promise<boolean> {
   try {
     console.log(`📧 Sending invoice notification for ${subscription.id} to ${subscription.customers.email}`);
     
     // Get environment variables - use the correct SERVICE_ROLE_KEY
     const supabaseUrl = Deno.env.get('SUPABASE_URL') ?? '';
     const serviceRoleKey = Deno.env.get('SERVICE_ROLE_KEY') ?? '';
     
     console.log(`🔧 Environment check: URL=${!!supabaseUrl}, Key=${!!serviceRoleKey}`);
     console.log(`🔧 Service key preview: ${serviceRoleKey.substring(0, 20)}...`);
     console.log(`🔧 Supabase URL: ${supabaseUrl}`);
     
     const requestPayload = {
       type: 'invoice',
       subscription_id: subscription.id,
       customer_email: subscription.customers.email,
       payment_url: paymentUrl,
       invoice_data: {
         amount: invoiceAmount
       }
     };
     
diff --git a/supabase/functions/subscriptions-scheduler/index.ts b/supabase/functions/subscriptions-scheduler/index.ts
index 2ba7918dd0c652653ae9b2899d951d91180939ee..2863398839985a407c128aad3d81f80b47b73907 100644
--- a/supabase/functions/subscriptions-scheduler/index.ts
+++ b/supabase/functions/subscriptions-scheduler/index.ts
@@ -313,55 +403,57 @@ Deno.serve(async (req) => {
 
     if (!supabaseUrl || !supabaseKey) {
       return new Response(JSON.stringify({ 
         success: false, 
         error: 'Server configuration error' 
       }), {
         status: 500,
         headers: { ...corsHeaders, 'Content-Type': 'application/json' }
       });
     }
 
     const supabase = createClient(supabaseUrl, supabaseKey, {
       auth: { autoRefreshToken: false, persistSession: false }
     });
 
     // Get current time in UTC for comparison
     const now = DateTime.now();
     const checkTime = now.plus({ days: 1 }); // Look ahead 1 day to catch early generation
     
     console.log(`🔍 Checking for subscriptions due before: ${checkTime.toISO()}`);
 
     // Find subscriptions that need invoice generation
     const { data: subscriptions, error: subscriptionsError } = await supabase
       .from('subscriptions')
       .select(`
-        id, title, amount, currency, interval, interval_count, 
+        id, title, amount, currency, accepted_cryptos, charge_customer_fee,
+        auto_convert_enabled, preferred_payout_currency, tax_enabled, tax_rates,
+        interval, interval_count,
         next_billing_at, status, max_cycles, total_cycles,
         merchant_id, customer_id,
-        invoice_due_days, generate_days_in_advance,
-        merchants!inner(id, business_name, timezone),
+        invoice_due_days, generate_days_in_advance, past_due_after_days,
+        merchants!inner(id, business_name, timezone, wallets, charge_customer_fee, auto_convert_enabled, preferred_payout_currency),
         customers!inner(id, name, email)
       `)
       .eq('status', 'active')
       .not('next_billing_at', 'is', null)
       .lte('next_billing_at', checkTime.toISO());
 
     if (subscriptionsError) {
       console.error('❌ Error fetching subscriptions:', subscriptionsError);
       return new Response(JSON.stringify({ 
         success: false, 
         error: 'Failed to fetch subscriptions' 
       }), {
         status: 500,
         headers: { ...corsHeaders, 'Content-Type': 'application/json' }
       });
     }
 
     console.log(`📋 Found ${subscriptions?.length || 0} subscriptions to process`);
 
     if (!subscriptions || subscriptions.length === 0) {
       return new Response(JSON.stringify({ 
         success: true, 
         message: 'No subscriptions due for processing',
         processed: 0
       }), {
 
EOF
)