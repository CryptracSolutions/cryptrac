import jsPDF from 'jspdf'
import autoTable from 'jspdf-autotable'
import * as XLSX from 'xlsx'

export interface ExportTransaction {
  id: string
  payment_id: string
  created_at: string
  product_description: string
  gross_amount: number
  tax_label: string
  tax_percentage: number
  tax_amount: number
  total_paid: number
  fees: number
  fee_payer: 'merchant' | 'customer'
  net_amount: number
  status: string
  refund_amount: number
  refund_date: string | null
  public_receipt_id: string | null
  link_id: string | null
  tx_hash: string | null
  blockchain_network: string | null
  currency_received: string | null
  amount_received: number | null
}

export interface ExportSummary {
  total_transactions: number
  total_gross_sales: number
  total_tax_collected: number
  total_fees: number
  total_net_revenue: number
  date_range: {
    start_date: string
    end_date: string
  }
  generated_at: string
}

export interface MerchantInfo {
  business_name: string
  business_address?: string
  tax_id?: string
  contact_email?: string
  phone?: string
  website?: string
}

export type ExportTemplate = 'tax_filing' | 'accounting' | 'audit' | 'summary'

export interface ExportOptions {
  template: ExportTemplate
  includeReceiptUrls: boolean
  includeBlockchainLinks: boolean
  timezone: string
}

// PDF Generation Functions
export function generateTaxReportPDF(
  transactions: ExportTransaction[],
  summary: ExportSummary,
  merchantInfo: MerchantInfo,
  options: ExportOptions
): Promise<Blob> {
  return new Promise((resolve) => {
    const doc = new jsPDF()
    const pageWidth = doc.internal.pageSize.width
    const pageHeight = doc.internal.pageSize.height

    // Header
    doc.setFontSize(20)
    doc.setFont('helvetica', 'bold')
    doc.text('Tax Report', pageWidth / 2, 20, { align: 'center' })

    doc.setFontSize(12)
    doc.setFont('helvetica', 'normal')
    doc.text(`Generated: ${new Date(summary.generated_at).toLocaleString()}`, pageWidth / 2, 30, { align: 'center' })
    doc.text(`Period: ${formatDate(summary.date_range.start_date)} - ${formatDate(summary.date_range.end_date)}`, pageWidth / 2, 37, { align: 'center' })

    // Business Information
    let yPos = 50
    doc.setFontSize(14)
    doc.setFont('helvetica', 'bold')
    doc.text('Business Information', 14, yPos)

    yPos += 10
    doc.setFontSize(10)
    doc.setFont('helvetica', 'normal')
    doc.text(`Business Name: ${merchantInfo.business_name}`, 14, yPos)

    if (merchantInfo.business_address) {
      yPos += 5
      doc.text(`Address: ${merchantInfo.business_address}`, 14, yPos)
    }

    if (merchantInfo.tax_id) {
      yPos += 5
      doc.text(`Tax ID: ${merchantInfo.tax_id}`, 14, yPos)
    }

    if (merchantInfo.contact_email) {
      yPos += 5
      doc.text(`Email: ${merchantInfo.contact_email}`, 14, yPos)
    }

    // Summary Section
    yPos += 15
    doc.setFontSize(14)
    doc.setFont('helvetica', 'bold')
    doc.text('Summary', 14, yPos)

    yPos += 10
    doc.setFontSize(10)
    doc.setFont('helvetica', 'normal')
    doc.text(`Total Transactions: ${summary.total_transactions}`, 14, yPos)

    yPos += 5
    doc.text(`Gross Sales: $${summary.total_gross_sales.toFixed(2)}`, 14, yPos)

    yPos += 5
    doc.text(`Tax Collected: $${summary.total_tax_collected.toFixed(2)}`, 14, yPos)

    yPos += 5
    doc.text(`Total Fees: $${summary.total_fees.toFixed(2)}`, 14, yPos)

    yPos += 5
    doc.text(`Net Revenue: $${summary.total_net_revenue.toFixed(2)}`, 14, yPos)

    // Transaction Table
    yPos += 15

    const columns = getColumnsForTemplate(options.template)
    const rows = transactions.map(tx => getRowDataForTemplate(tx, options))

    autoTable(doc, {
      head: [columns],
      body: rows,
      startY: yPos,
      styles: { fontSize: 8, cellPadding: 2 },
      headStyles: { fillColor: [127, 94, 253], textColor: 255 },
      columnStyles: {
        0: { cellWidth: 25 }, // Date
        1: { cellWidth: 40 }, // Description
        2: { cellWidth: 20 }, // Amount
      },
      margin: { left: 14, right: 14 },
      didDrawPage: () => {
        // Footer on every page
        const pageNumber = (doc as any).internal.getNumberOfPages()
        doc.setFontSize(8)
        doc.text(`Page ${pageNumber}`, pageWidth - 20, pageHeight - 10, { align: 'right' })
        doc.text(`Generated by Cryptrac - ${new Date().toISOString()}`, 14, pageHeight - 10)
      }
    })

    resolve(new Blob([doc.output('blob')], { type: 'application/pdf' }))
  })
}

// Excel Generation Functions
export function generateTaxReportExcel(
  transactions: ExportTransaction[],
  summary: ExportSummary,
  merchantInfo: MerchantInfo,
  options: ExportOptions
): Blob {
  const workbook = XLSX.utils.book_new()

  // Summary Sheet
  const summaryData = [
    ['Cryptrac Tax Report'],
    [''],
    ['Business Information'],
    ['Business Name', merchantInfo.business_name],
    ['Tax ID', merchantInfo.tax_id || ''],
    ['Contact Email', merchantInfo.contact_email || ''],
    [''],
    ['Report Summary'],
    ['Generated', new Date(summary.generated_at).toLocaleString()],
    ['Period Start', formatDate(summary.date_range.start_date)],
    ['Period End', formatDate(summary.date_range.end_date)],
    ['Total Transactions', summary.total_transactions],
    ['Gross Sales', summary.total_gross_sales],
    ['Tax Collected', summary.total_tax_collected],
    ['Total Fees', summary.total_fees],
    ['Net Revenue', summary.total_net_revenue]
  ]

  const summarySheet = XLSX.utils.aoa_to_sheet(summaryData)
  XLSX.utils.book_append_sheet(workbook, summarySheet, 'Summary')

  // Transactions Sheet
  const headers = getExcelHeadersForTemplate(options.template)
  const transactionData = [
    headers,
    ...transactions.map(tx => getExcelRowDataForTemplate(tx, options))
  ]

  const transactionSheet = XLSX.utils.aoa_to_sheet(transactionData)
  XLSX.utils.book_append_sheet(workbook, transactionSheet, 'Transactions')

  // Generate Excel file
  const excelBuffer = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' })
  return new Blob([excelBuffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' })
}

// Enhanced CSV Generation
export function generateEnhancedCSV(
  transactions: ExportTransaction[],
  summary: ExportSummary,
  merchantInfo: MerchantInfo,
  options: ExportOptions
): string {
  const headers = getCSVHeadersForTemplate(options.template)

  const csvContent = [
    `# Cryptrac Tax Report - ${options.template.replace('_', ' ').toUpperCase()}`,
    `# Generated: ${new Date(summary.generated_at).toLocaleString()}`,
    `# Date Range: ${formatDate(summary.date_range.start_date)} to ${formatDate(summary.date_range.end_date)}`,
    `# Business: ${merchantInfo.business_name}`,
    merchantInfo.tax_id ? `# Tax ID: ${merchantInfo.tax_id}` : '',
    `# Total Transactions: ${summary.total_transactions}`,
    `# Total Gross Sales: $${summary.total_gross_sales.toFixed(2)}`,
    `# Total Tax Collected: $${summary.total_tax_collected.toFixed(2)}`,
    `# Total Fees: $${summary.total_fees.toFixed(2)}`,
    `# Total Net Revenue: $${summary.total_net_revenue.toFixed(2)}`,
    ``,
    headers.join(','),
    ...transactions.map(tx => getCSVRowDataForTemplate(tx, options).join(','))
  ].filter(line => line !== '').join('\n')

  return csvContent
}

// Template-specific column configurations
function getColumnsForTemplate(template: ExportTemplate): string[] {
  const baseColumns = ['Date', 'Description', 'Gross Amount', 'Tax', 'Fees', 'Fee Payer', 'Net Amount', 'Status']

  switch (template) {
    case 'tax_filing':
      return ['Date', 'Description', 'Gross Amount', 'Tax Rate', 'Tax Amount', 'Status', 'Tax ID']
    case 'accounting':
      return [...baseColumns, 'Link ID', 'Currency', 'Receipt']
    case 'audit':
      return [...baseColumns, 'TX Hash', 'Blockchain', 'Link ID', 'Receipt URL']
    case 'summary':
      return ['Date', 'Description', 'Total Amount', 'Status']
    default:
      return baseColumns
  }
}

function getRowDataForTemplate(tx: ExportTransaction, options: ExportOptions): string[] {
  const baseData = [
    formatDate(tx.created_at),
    tx.product_description,
    `$${tx.gross_amount.toFixed(2)}`,
    `$${tx.tax_amount.toFixed(2)}`,
    `$${tx.fees.toFixed(2)}`,
    tx.fee_payer,
    `$${tx.net_amount.toFixed(2)}`,
    tx.status
  ]

  switch (options.template) {
    case 'tax_filing':
      return [
        formatDate(tx.created_at),
        tx.product_description,
        `$${tx.gross_amount.toFixed(2)}`,
        `${tx.tax_percentage}%`,
        `$${tx.tax_amount.toFixed(2)}`,
        tx.status,
        tx.link_id || ''
      ]
    case 'accounting':
      return [...baseData, tx.link_id || '', tx.currency_received || '', options.includeReceiptUrls && tx.public_receipt_id ? 'Yes' : 'No']
    case 'audit':
      return [...baseData, tx.tx_hash || '', tx.blockchain_network || '', tx.link_id || '', options.includeReceiptUrls && tx.public_receipt_id ? `${process.env.NEXT_PUBLIC_APP_URL}/r/${tx.public_receipt_id}` : '']
    case 'summary':
      return [formatDate(tx.created_at), tx.product_description, `$${tx.total_paid.toFixed(2)}`, tx.status]
    default:
      return baseData
  }
}

function getExcelHeadersForTemplate(template: ExportTemplate): string[] {
  return getColumnsForTemplate(template)
}

function getExcelRowDataForTemplate(tx: ExportTransaction, options: ExportOptions): (string | number)[] {
  const rowData = getRowDataForTemplate(tx, options)
  return rowData.map(cell => {
    // Convert dollar amounts to numbers for Excel
    if (typeof cell === 'string' && cell.startsWith('$')) {
      return parseFloat(cell.substring(1))
    }
    return cell
  })
}

function getCSVHeadersForTemplate(template: ExportTemplate): string[] {
  return getColumnsForTemplate(template)
}

function getCSVRowDataForTemplate(tx: ExportTransaction, options: ExportOptions): string[] {
  const rowData = getRowDataForTemplate(tx, options)
  return rowData.map(cell => {
    if (typeof cell === 'string' && cell.includes(',')) {
      return `"${cell}"`
    }
    return String(cell)
  })
}

// Utility functions
function formatDate(dateString: string): string {
  return new Date(dateString).toLocaleDateString('en-US', {
    year: 'numeric',
    month: '2-digit',
    day: '2-digit'
  })
}

// Blockchain explorer URL generators
export function getBlockchainExplorerUrl(txHash: string, network: string): string {
  const networkMap: Record<string, string> = {
    'bitcoin': `https://blockstream.info/tx/${txHash}`,
    'btc': `https://blockstream.info/tx/${txHash}`,
    'ethereum': `https://etherscan.io/tx/${txHash}`,
    'eth': `https://etherscan.io/tx/${txHash}`,
    'litecoin': `https://blockexplorer.one/litecoin/mainnet/tx/${txHash}`,
    'ltc': `https://blockexplorer.one/litecoin/mainnet/tx/${txHash}`,
    'dogecoin': `https://dogechain.info/tx/${txHash}`,
    'doge': `https://dogechain.info/tx/${txHash}`,
    'bitcoin-cash': `https://blockchair.com/bitcoin-cash/transaction/${txHash}`,
    'bch': `https://blockchair.com/bitcoin-cash/transaction/${txHash}`,
    'polygon': `https://polygonscan.com/tx/${txHash}`,
    'matic': `https://polygonscan.com/tx/${txHash}`,
    'binance-smart-chain': `https://bscscan.com/tx/${txHash}`,
    'bsc': `https://bscscan.com/tx/${txHash}`,
    'bnb': `https://bscscan.com/tx/${txHash}`,
    'tron': `https://tronscan.org/#/transaction/${txHash}`,
    'trx': `https://tronscan.org/#/transaction/${txHash}`,
    'solana': `https://solscan.io/tx/${txHash}`,
    'sol': `https://solscan.io/tx/${txHash}`,
    'avalanche': `https://snowtrace.io/tx/${txHash}`,
    'avax': `https://snowtrace.io/tx/${txHash}`,
    'avaxc': `https://snowtrace.io/tx/${txHash}`,
    'avalanche-c-chain': `https://snowtrace.io/tx/${txHash}`,
    'cardano': `https://cardanoscan.io/transaction/${txHash}`,
    'ada': `https://cardanoscan.io/transaction/${txHash}`,
    'arbitrum': `https://arbiscan.io/tx/${txHash}`,
    'arb': `https://arbiscan.io/tx/${txHash}`,
    'optimism': `https://optimistic.etherscan.io/tx/${txHash}`,
    'op': `https://optimistic.etherscan.io/tx/${txHash}`,
    'base': `https://basescan.org/tx/${txHash}`,
    'ethbase': `https://basescan.org/tx/${txHash}`,
    'fantom': `https://ftmscan.com/tx/${txHash}`,
    'ftm': `https://ftmscan.com/tx/${txHash}`,
    'cosmos': `https://www.mintscan.io/cosmos/txs/${txHash}`,
    'atom': `https://www.mintscan.io/cosmos/txs/${txHash}`,
    'near': `https://nearblocks.io/txs/${txHash}`,
    'algorand': `https://algoexplorer.io/tx/${txHash}`,
    'algo': `https://algoexplorer.io/tx/${txHash}`,
    'ton': `https://tonscan.org/tx/${txHash}`,
    'ripple': `https://xrpscan.com/tx/${txHash}`,
    'xrp': `https://xrpscan.com/tx/${txHash}`,
    'stellar': `https://stellarchain.io/transactions/${txHash}`,
    'xlm': `https://stellarchain.io/transactions/${txHash}`
  }

  return networkMap[network.toLowerCase()] || `https://blockchain.info/tx/${txHash}`
}